{
  "permissions": {
    "allow": [
      "Bash(find:*)",
      "Bash(ls:*)",
      "Bash(cmd /c dir:*)",
      "Bash(\"D:\\\\project\\\\openclaw\\\\docs\\\\ko-KR\\\\gateway\\\\discovery.md\" << 'ENDOFFILE'\n---\nsummary: \"노드 디스커버리와 트랜스포트 \\(Bonjour, Tailscale, SSH\\)\"\nread_when:\n  - 노드가 Gateway를 찾는 방법을 이해하고 싶을 때\n  - Bonjour/mDNS 설정을 변경하고 싶을 때\n  - 원격 연결 모드를 조정하고 싶을 때\ntitle: \"디스커버리와 트랜스포트\"\n---\n\n# 디스커버리와 트랜스포트\n\n클라이언트\\(노드, CLI, 웹 UI\\)가 Gateway를 찾고 연결하는 방법을 설명합니다.\n\n## 디스커버리 입력\n\n클라이언트는 다음 방법 중 하나로 Gateway를 찾습니다:\n\n```mermaid\nflowchart TD\n    Client[\"클라이언트\"] --> Bonjour[\"Bonjour/mDNS\\\\n\\(로컬 네트워크\\)\"]\n    Client --> Tailnet[\"Tailscale\\\\n\\(크로스 네트워크\\)\"]\n    Client --> Manual[\"수동 지정\\\\n\\(SSH / 직접 URL\\)\"]\n    Bonjour --> GW[\"Gateway\"]\n    Tailnet --> GW\n    Manual --> GW\n```\n\n## Bonjour / mDNS\n\nGateway는 로컬 네트워크에 mDNS 서비스를 브로드캐스트합니다.\n\n### 서비스 타입\n\n```\n_openclaw-gw._tcp\n```\n\n### TXT 레코드\n\n| 키             | 설명                          | 예시                     |\n| -------------- | ----------------------------- | ------------------------ |\n| `role`         | 서비스 역할                   | `gateway`                |\n| `lanHost`      | LAN 호스트 주소               | `192.168.1.100`          |\n| `sshPort`      | SSH 포트                      | `22`                     |\n| `gatewayPort`  | Gateway WebSocket 포트        | `18789`                  |\n| `gatewayTls`   | TLS 활성 여부                 | `true`                   |\n| `canvasPort`   | Canvas 서버 포트              | `18790`                  |\n| `cliPath`      | CLI 실행 파일 경로            | `/usr/local/bin/openclaw`|\n| `tailnetDns`   | Tailscale DNS 이름            | `myhost.tail12345.ts.net`|\n\n### 기본 엔드포인트\n\n```\nws://127.0.0.1:18789\n```\n\n### 비활성화\n\n```bash\nOPENCLAW_DISABLE_BONJOUR=1 openclaw gateway\n```\n\n## Tailscale \\(크로스 네트워크\\)\n\n같은 Tailnet에 속한 기기들은 Tailscale DNS를 통해 Gateway를 찾습니다.\n\n```json5\n{\n  gateway: {\n    bind: \"tailscale\",  // Tailscale 인터페이스에 바인딩\n  },\n}\n```\n\n환경 변수:\n\n```bash\nOPENCLAW_TAILNET_DNS=myhost.tail12345.ts.net\n```\n\nTXT 레코드의 `tailnetDns` 필드를 통해 노드가 Tailnet 주소를 자동으로 발견합니다.\n\n## 수동 / SSH\n\nBonjour가 불가능한 환경에서는 직접 지정합니다:\n\n```bash\n# SSH를 통한 원격 연결\nopenclaw --remote ssh://user@host\n\n# 직접 URL 지정\nopenclaw --remote ws://192.168.1.100:18789\n```\n\n환경 변수:\n\n```bash\nOPENCLAW_SSH_PORT=22\nOPENCLAW_CLI_PATH=/usr/local/bin/openclaw\n```\n\n## 트랜스포트 선택\n\n클라이언트는 정책에 따라 트랜스포트를 선택합니다:\n\n| 트랜스포트     | 사용 조건                       | 지연 시간 |\n| -------------- | ------------------------------- | --------- |\n| **직접 WS**    | 로컬 네트워크, Tailnet          | 최저      |\n| **SSH 터널**   | 원격 서버, NAT 뒤              | 중간      |\n| **Tailscale**  | 크로스 네트워크 자동 연결       | 중간      |\n\n### 바인드 모드\n\n```json5\n{\n  gateway: {\n    bind: \"loopback\",    // 127.0.0.1만 \\(기본\\)\n    // bind: \"lan\",       // LAN IP에 바인딩\n    // bind: \"tailscale\", // Tailscale 인터페이스\n    // bind: \"0.0.0.0\",   // 모든 인터페이스 \\(주의\\)\n  },\n}\n```\n\n## 페어링과 인증\n\n노드가 Gateway에 처음 연결할 때:\n\n1. 노드가 Bonjour 또는 수동으로 Gateway를 발견\n2. 페어링 요청 전송 \\(디바이스 정보 포함\\)\n3. Gateway가 페어링 승인 \\(토큰 또는 비밀번호\\)\n4. 이후 연결 시 저장된 자격 증명 사용\n\n### 직접 트랜스포트 인증\n\n```mermaid\nsequenceDiagram\n    participant Node as 노드\n    participant GW as Gateway\n    Node->>GW: 페어링 요청 \\(deviceInfo\\)\n    GW->>Node: 페어링 승인 \\(token\\)\n    Note over Node,GW: 이후 연결\n    Node->>GW: connect \\(auth: token\\)\n    GW->>Node: 연결 성공\n```\n\n## 컴포넌트별 역할\n\n| 컴포넌트        | 역할                                        |\n| --------------- | ------------------------------------------- |\n| **Gateway**     | mDNS 비콘 게시, WS/HTTP 리스닝, 페어링 관리 |\n| **CLI**         | mDNS 탐색 또는 수동 URL로 연결              |\n| **macOS 앱**    | Bonjour 자동 발견, SSH 폴백                 |\n| **iOS/Android** | Bonjour 스캔, Tailnet 발견, 수동 입력       |\n| **Control UI**  | 브라우저에서 WS 직접 연결                   |\n\n## 다음 단계\n\n- [Gateway 프로토콜]\\(/ko-KR/gateway/protocol\\) - WebSocket 프로토콜과 RPC 메서드\n- [원격 접근]\\(/ko-KR/gateway/remote\\) - SSH 터널과 VPN 설정\n- [보안]\\(/ko-KR/gateway/security\\) - 인증과 접근 제어\nENDOFFILE)",
      "Bash(\"D:\\\\project\\\\openclaw\\\\docs\\\\ko-KR\\\\gateway\\\\remote.md\" << 'ENDOFFILE'\n---\nsummary: \"SSH 터널, Tailscale, VPN을 통한 원격 Gateway 접근\"\nread_when:\n  - 원격에서 Gateway에 접근하고 싶을 때\n  - SSH 터널 설정이 필요할 때\n  - Tailscale로 연결하고 싶을 때\ntitle: \"원격 접근\"\n---\n\n# 원격 접근\n\nGateway WebSocket은 기본적으로 루프백\\(`127.0.0.1`\\)에 바인딩됩니다. 원격에서 접근하려면 SSH 터널, Tailnet, 또는 VPN을 사용합니다.\n\n## 핵심 아이디어\n\n```mermaid\nflowchart LR\n    Remote[\"원격 클라이언트\\\\n\\(노트북/모바일\\)\"] -->|SSH 터널 / Tailscale| Server[\"Gateway 서버\\\\n\\(127.0.0.1:18789\\)\"]\n    Server --> Agent[\"에이전트\"]\n    Server --> Tools[\"도구 \\(bash, browser\\)\"]\n```\n\nGateway는 **로컬**에서 에이전트와 도구를 실행하고, 클라이언트는 **원격**에서 채팅과 제어만 수행합니다.\n\n## 일반적인 시나리오\n\n### 1. Tailnet 상시 서버\n\nVPS나 홈 서버에서 Gateway를 항상 실행합니다:\n\n```bash\n# 서버에서\nopenclaw gateway --port 18789\n```\n\n```bash\n# 원격 클라이언트에서 \\(같은 Tailnet\\)\nopenclaw --remote ws://myserver.tail12345.ts.net:18789\n```\n\n### 2. 데스크톱 Gateway + 노트북 제어\n\n집 데스크톱에서 Gateway를 실행하고, 외부에서 노트북으로 접근합니다:\n\n```bash\n# 데스크톱에서\nopenclaw gateway\n\n# 노트북에서 \\(SSH 터널\\)\nssh -N -L 18789:127.0.0.1:18789 user@desktop-ip\nopenclaw --remote ws://127.0.0.1:18789\n```\n\n### 3. 노트북 Gateway 외부 노출\n\n노트북에서 Gateway를 실행하되 모바일에서도 접근합니다:\n\n```bash\n# 노트북에서\nopenclaw gateway\n\n# Tailscale Serve로 노출\ntailscale serve --bg 18789\n```\n\n## 명령어 흐름 \\(무엇이 어디서 실행되나?\\)\n\n| 구성 요소           | 실행 위치      | 설명                       |\n| ------------------- | -------------- | -------------------------- |\n| **Gateway 프로세스** | 서버 \\(로컬\\)    | 세션, 라우팅, 에이전트 관리 |\n| **에이전트 \\(Pi\\)**    | 서버 \\(로컬\\)    | LLM 호출, 도구 실행        |\n| **bash/exec 도구**   | 서버 \\(로컬\\)    | 파일 시스템 접근 포함      |\n| **browser 도구**     | 서버 \\(로컬\\)    | Chrome 프로필 사용         |\n| **CLI 클라이언트**   | 원격 \\(클라이언트\\)| 채팅 입출력만              |\n| **Control UI**       | 원격 \\(브라우저\\) | WebSocket으로 연결         |\n\n## SSH 터널\n\n### 기본 터널 \\(CLI + 도구\\)\n\n```bash\nssh -N -L 18789:127.0.0.1:18789 user@server-host\n```\n\n### 지속 연결 \\(autossh\\)\n\n```bash\nautossh -M 0 -N -L 18789:127.0.0.1:18789 user@server-host\n```\n\n### SSH 설정 \\(편의\\)\n\n`~/.ssh/config`에 추가:\n\n```\nHost openclaw-server\n    HostName server-ip-or-hostname\n    User your-user\n    LocalForward 18789 127.0.0.1:18789\n```\n\n```bash\nssh -N openclaw-server\n```\n\n## CLI 원격 기본값\n\n```json5\n{\n  gateway: {\n    mode: \"remote\",\n    remote: {\n      url: \"ws://127.0.0.1:18789\",\n      token: \"your-gateway-token\",\n    },\n  },\n}\n```\n\n환경 변수로도 설정 가능:\n\n```bash\nexport OPENCLAW_GATEWAY_URL=ws://127.0.0.1:18789\nexport OPENCLAW_GATEWAY_TOKEN=your-gateway-token\n```\n\n## 채팅 UI over SSH\n\n헤드리스 서버에서 TUI를 직접 사용합니다:\n\n```bash\nssh user@server openclaw tui\n```\n\n또는 tmux/screen 세션 안에서:\n\n```bash\nssh user@server\ntmux new -s openclaw\nopenclaw tui\n```\n\n## macOS 앱: Remote over SSH\n\nmacOS 앱에서 원격 서버의 Gateway에 SSH로 연결합니다:\n\n1. 설정 → Remote → SSH 연결 추가\n2. 호스트, 사용자, 키 경로 입력\n3. 앱이 SSH 터널을 자동으로 관리\n\n## 보안\n\n### 토큰 인증\n\n```json5\n{\n  gateway: {\n    auth: {\n      token: \"your-secure-token\",  // 원격 CLI 호출에 필요\n    },\n    remote: {\n      token: \"your-secure-token\",\n    },\n  },\n}\n```\n\n### TLS 인증서 핀닝\n\n```json5\n{\n  gateway: {\n    remote: {\n      tlsFingerprint: \"sha256://abc123...\",  // 원격 TLS 인증서 핀\n    },\n  },\n}\n```\n\n### Tailscale 인증\n\n```json5\n{\n  gateway: {\n    auth: {\n      allowTailscale: true,  // Tailscale 아이덴티티 헤더로 인증\n    },\n  },\n}\n```\n\n### 보안 권장 사항\n\n| 항목                  | 권장                                         |\n| --------------------- | -------------------------------------------- |\n| **공개 인터넷 노출**  | ❌ 하지 마세요 — SSH/Tailscale 사용          |\n| **localhost 바인딩**   | ✅ 기본값 유지                               |\n| **토큰 설정**         | ✅ 원격 접근 시 반드시 설정                  |\n| **TLS**               | ✅ 가능하면 활성화                           |\n| **Tailscale Serve**   | ✅ 가장 간편한 보안 원격 접근               |\n\n## 다음 단계\n\n- [디스커버리]\\(/ko-KR/gateway/discovery\\) - 노드 디스커버리 프로토콜\n- [보안]\\(/ko-KR/gateway/security\\) - Gateway 보안 설정\n- [대시보드]\\(/ko-KR/web/dashboard\\) - 웹 UI 접근\n- [Tailscale]\\(/ko-KR/gateway/tailscale\\) - Tailscale 통합\nENDOFFILE)",
      "Bash(\"D:\\\\project\\\\openclaw\\\\docs\\\\ko-KR\\\\gateway\\\\background-process.md\" << 'ENDOFFILE'\n---\nsummary: \"백그라운드 exec 실행과 프로세스 관리 도구\"\nread_when:\n  - 장시간 실행되는 명령어의 동작을 이해하고 싶을 때\n  - 백그라운드 프로세스를 관리하고 싶을 때\n  - exec 도구의 상세 파라미터를 알고 싶을 때\ntitle: \"백그라운드 Exec과 프로세스 도구\"\n---\n\n# 백그라운드 Exec과 프로세스 도구\n\n`exec` 도구로 실행한 명령어가 일정 시간을 초과하면 자동으로 백그라운드로 전환됩니다. `process` 도구로 백그라운드 프로세스를 모니터링하고 관리합니다.\n\n## exec 도구 파라미터\n\n| 파라미터     | 타입      | 기본값   | 설명                                      |\n| ------------ | --------- | -------- | ----------------------------------------- |\n| `command`    | `string`  | \\(필수\\)   | 실행할 명령어                             |\n| `yieldMs`    | `number`  | `10000`  | 이 시간 후 자동 백그라운드 전환 \\(ms\\)      |\n| `background` | `boolean` | `false`  | 즉시 백그라운드로 실행                    |\n| `timeout`    | `number`  | `1800`   | 이 시간 후 프로세스 종료 \\(초\\)             |\n| `elevated`   | `boolean` | `false`  | 호스트에서 직접 실행 \\(허용된 경우\\)        |\n| `pty`        | `boolean` | `false`  | 실제 TTY 할당                             |\n| `workdir`    | `string`  | —        | 작업 디렉토리                             |\n| `env`        | `object`  | —        | 추가 환경 변수                            |\n\n## 동작 방식\n\n```mermaid\nflowchart TD\n    Start[\"exec 실행\"] --> Check{\"yieldMs\\\\n초과?\"}\n    Check -->|아니오| Wait[\"결과 대기\"]\n    Wait --> Done[\"결과 반환\"]\n    Check -->|예| BG[\"백그라운드 전환\"]\n    BG --> Session[\"세션 ID 반환\"]\n    Session --> Poll[\"process.poll로\\\\n출력 확인\"]\n```\n\n### 자동 백그라운드 전환\n\n1. 에이전트가 `exec` 도구를 호출\n2. `yieldMs` \\(기본 10초\\) 동안 결과 대기\n3. 시간 초과 시 자동으로 백그라운드 세션 생성\n4. 세션 ID를 에이전트에 반환\n5. 에이전트는 `process` 도구로 상태 확인\n\n### 즉시 백그라운드 실행\n\n```json\n{\n  \"tool\": \"exec\",\n  \"command\": \"npm run build\",\n  \"background\": true\n}\n```\n\n## 자식 프로세스 브릿지\n\n백그라운드 프로세스의 stdout/stderr는 브릿지를 통해 수집됩니다:\n\n- 출력은 인메모리 버퍼에 저장\n- `process.poll`로 새로운 출력을 가져옴\n- `process.log`로 전체 출력을 읽음\n\n## process 도구 액션\n\n| 액션       | 설명                                     | 파라미터                           |\n| ---------- | ---------------------------------------- | ---------------------------------- |\n| `list`     | 실행 중 + 완료된 세션 목록               | —                                  |\n| `poll`     | 새로운 출력 가져오기                     | `sessionId`                        |\n| `log`      | 전체 출력 읽기 \\(offset/limit 지원\\)       | `sessionId`, `offset?`, `limit?`   |\n| `write`    | stdin에 입력 전송                        | `sessionId`, `data`                |\n| `kill`     | 실행 중인 세션 종료                      | `sessionId`                        |\n| `clear`    | 완료된 세션 제거                         | `sessionId`                        |\n| `remove`   | 실행 중이면 kill, 완료되었으면 clear     | `sessionId`                        |\n\n## 사용 예시\n\n### 장시간 빌드\n\n```json\n{ \"tool\": \"exec\", \"command\": \"npm run build\", \"background\": true }\n```\n\n```json\n{ \"tool\": \"process\", \"action\": \"poll\", \"sessionId\": \"<id>\" }\n```\n\n### 자동 백그라운드 전환\n\n```json\n{ \"tool\": \"exec\", \"command\": \"sleep 5 && echo done\", \"yieldMs\": 1000 }\n```\n\n1초 후 자동으로 백그라운드로 전환되며 세션 ID가 반환됩니다.\n\n### stdin 입력\n\n인터랙티브 프로그램에 입력을 보냅니다:\n\n```json\n{ \"tool\": \"process\", \"action\": \"write\", \"sessionId\": \"<id>\", \"data\": \"y\\\\n\" }\n```\n\n### 출력 확인 \\(페이지네이션\\)\n\n```json\n{ \"tool\": \"process\", \"action\": \"log\", \"sessionId\": \"<id>\", \"offset\": 0, \"limit\": 100 }\n```\n\n### 세션 정리\n\n```json\n{ \"tool\": \"process\", \"action\": \"remove\", \"sessionId\": \"<id>\" }\n```\n\n## 환경 변수와 설정\n\n### 환경 변수\n\n| 변수                                       | 기본값  | 설명                             |\n| ------------------------------------------ | ------- | -------------------------------- |\n| `PI_BASH_YIELD_MS`                         | `10000` | 자동 백그라운드 전환 시간 \\(ms\\)   |\n| `PI_BASH_MAX_OUTPUT_CHARS`                 | —       | 인메모리 출력 최대 크기          |\n| `OPENCLAW_BASH_PENDING_MAX_OUTPUT_CHARS`   | —       | pending stdout/stderr 최대 크기  |\n| `PI_BASH_JOB_TTL_MS`                       | —       | 완료된 세션 TTL \\(1분~3시간\\)     |\n\n### 설정 파일\n\n```json5\n{\n  tools: {\n    exec: {\n      backgroundMs: 10000,     // 자동 백그라운드 전환 \\(ms\\)\n      timeoutSec: 1800,        // 최대 실행 시간 \\(초, 기본 30분\\)\n      cleanupMs: 1800000,      // 완료 세션 정리 시간 \\(ms\\)\n      notifyOnExit: true,      // 완료 시 에이전트에 알림\n    },\n  },\n}\n```\n\n### notifyOnExit\n\n`true` \\(기본\\)일 때, 백그라운드 프로세스가 완료되면 에이전트에 시스템 이벤트로 알립니다. 에이전트는 다음 턴에서 결과를 확인할 수 있습니다.\n\n## 보안 고려사항\n\n- `elevated: true`는 샌드박스를 우회하여 호스트에서 직접 실행합니다\n- `pty: true`는 TTY가 필요한 인터랙티브 프로그램에 사용합니다\n- 장시간 프로세스는 `timeout`으로 제한하세요\n- 민감한 명령어는 승인 워크플로우를 통해 실행됩니다\n\n## 다음 단계\n\n- [명령어 실행]\\(/ko-KR/tools/exec\\) - exec 도구 보안 모드\n- [멀티 에이전트 샌드박스]\\(/ko-KR/tools/multi-agent-sandbox-tools\\) - 도구 접근 제어\n- [에이전트 실행 루프]\\(/ko-KR/concepts/agent-loop\\) - 도구 실행 단계\nENDOFFILE)",
      "Bash(\"D:\\\\project\\\\openclaw\\\\docs\\\\ko-KR\\\\nodes\\\\voicewake.md\" << 'ENDOFFILE'\n---\nsummary: \"글로벌 음성 웨이크 워드 설정과 노드 간 동기화\"\nread_when:\n  - 음성 웨이크 워드를 변경하고 싶을 때\n  - 웨이크 워드가 노드 간에 어떻게 동기화되는지 알고 싶을 때\ntitle: \"음성 웨이크\"\n---\n\n# 음성 웨이크\n\n음성 웨이크 워드는 Gateway에서 중앙 관리되며 모든 노드에 동기화됩니다. 사용자가 웨이크 워드를 말하면 에이전트가 활성화됩니다.\n\n## 저장소\n\n웨이크 워드는 Gateway 호스트에 저장됩니다:\n\n```\n~/.openclaw/settings/voicewake.json\n```\n\n### JSON 구조\n\n```json\n{\n  \"triggers\": [\"openclaw\", \"claude\", \"computer\"],\n  \"updatedAtMs\": 1730000000000\n}\n```\n\n- `triggers`: 인식할 웨이크 워드 목록\n- `updatedAtMs`: 마지막 업데이트 타임스탬프\n\n## 프로토콜\n\n### 메서드\n\n| 메서드           | 파라미터                      | 반환                       | 설명                |\n| ---------------- | ----------------------------- | -------------------------- | ------------------- |\n| `voicewake.get`  | —                             | `{ triggers: string[] }`   | 현재 웨이크 워드 조회 |\n| `voicewake.set`  | `{ triggers: string[] }`      | `{ triggers: string[] }`   | 웨이크 워드 설정     |\n\n### 이벤트\n\n| 이벤트               | 페이로드                   | 설명                           |\n| -------------------- | -------------------------- | ------------------------------ |\n| `voicewake.changed`  | `{ triggers: string[] }`   | 웨이크 워드가 변경되었을 때    |\n\n### 동기화 흐름\n\n```mermaid\nsequenceDiagram\n    participant User as 사용자\n    participant Node1 as macOS 노드\n    participant GW as Gateway\n    participant Node2 as iOS 노드\n    participant Node3 as Android 노드\n\n    User->>Node1: 웨이크 워드 편집\n    Node1->>GW: voicewake.set\\(triggers\\)\n    GW->>GW: voicewake.json 저장\n    GW->>Node1: voicewake.changed 이벤트\n    GW->>Node2: voicewake.changed 이벤트\n    GW->>Node3: voicewake.changed 이벤트\n```\n\n어느 노드에서든 웨이크 워드를 변경하면 모든 연결된 노드에 즉시 전파됩니다.\n\n## 클라이언트별 구현\n\n### macOS\n\n- **VoiceWakeRuntime**이 글로벌 리스트를 사용하여 트리거 감지\n- 설정 UI에서 웨이크 워드를 편집하면 `voicewake.set` 호출\n- 변경 이벤트를 수신하여 런타임에 반영\n\n### iOS\n\n- **VoiceWakeManager**가 글로벌 리스트로 트리거 감지\n- 설정 화면에서 편집 시 `voicewake.set` 호출\n- 백그라운드에서도 웨이크 워드 감지 지원\n\n### Android\n\n- 설정 → Wake Words에서 편집 UI 제공\n- 변경 시 `voicewake.set` 호출\n- 이벤트 수신으로 실시간 업데이트\n\n## 기본 웨이크 워드\n\n설치 시 기본값:\n\n```json\n[\"openclaw\", \"claude\", \"computer\"]\n```\n\n### 커스터마이징 팁\n\n- 짧고 명확한 단어를 사용하세요 \\(2~3음절\\)\n- 일상 대화에서 잘 쓰이지 않는 단어가 좋습니다\n- 여러 언어를 지원하려면 각 언어별 웨이크 워드를 추가하세요\n\n## 문제 해결\n\n| 증상                         | 해결                                    |\n| ---------------------------- | --------------------------------------- |\n| 웨이크 워드가 인식되지 않음  | 마이크 권한 확인, 조용한 환경에서 테스트 |\n| 다른 노드에 동기화되지 않음  | Gateway 연결 상태 확인                  |\n| 오인식이 잦음                | 더 고유한 웨이크 워드로 변경            |\n\n## 다음 단계\n\n- [Talk 모드]\\(/ko-KR/nodes/talk\\) - 음성 대화 모드\n- [노드 및 미디어]\\(/ko-KR/nodes\\) - 모바일 노드 개요\n- [Gateway 프로토콜]\\(/ko-KR/gateway/protocol\\) - WebSocket 프로토콜\nENDOFFILE)",
      "Bash(\"D:\\\\project\\\\openclaw\\\\docs\\\\ko-KR\\\\nodes\\\\media-understanding.md\" << 'ENDOFFILE'\n---\nsummary: \"인바운드 이미지/오디오/비디오 이해와 프로바이더 설정\"\nread_when:\n  - 미디어 이해 기능을 설정하고 싶을 때\n  - 이미지/오디오/비디오 전처리를 조정하고 싶을 때\n  - 지원되는 프로바이더를 알고 싶을 때\ntitle: \"미디어 이해\"\n---\n\n# 미디어 이해\n\n인바운드 이미지, 오디오, 비디오를 에이전트가 이해할 수 있도록 텍스트로 변환합니다. 프로바이더 API 또는 로컬 CLI를 사용합니다.\n\n## 목표\n\n- 채팅으로 받은 미디어를 에이전트가 **이해**할 수 있게 변환\n- 이미지 → 설명 텍스트, 오디오 → 트랜스크립트, 비디오 → 장면 설명\n- 프로바이더 API와 로컬 CLI를 유연하게 조합\n\n## 동작 방식\n\n```mermaid\nflowchart LR\n    Media[\"인바운드 미디어\\\\n\\(이미지/오디오/비디오\\)\"] --> Check{\"설정된\\\\n모델?\"}\n    Check -->|있음| Model[\"프로바이더/CLI\\\\n처리\"]\n    Check -->|없음| Auto[\"자동 감지\"]\n    Auto --> Model\n    Model --> Text[\"텍스트 변환\"]\n    Text --> Agent[\"에이전트 컨텍스트에\\\\n주입\"]\n```\n\n## 설정 구조\n\n```json5\n{\n  tools: {\n    media: {\n      models: [/* 공유 모델 목록 */],\n      image: {/* 이미지 오버라이드 */},\n      audio: {/* 오디오 오버라이드 */},\n      video: {/* 비디오 오버라이드 */},\n    },\n  },\n}\n```\n\n## 모델 엔트리\n\n### 프로바이더 모델\n\n```json5\n{\n  type: \"provider\",        // 또는 생략 \\(기본\\)\n  provider: \"openai\",\n  model: \"gpt-5.2\",\n  prompt: \"이 이미지를 설명하세요\",\n  maxChars: 500,\n  maxBytes: 10485760,      // 10MB\n  timeoutSeconds: 30,\n  capabilities: [\"image\", \"audio\"],\n  profile: \"openai:default\",\n}\n```\n\n### CLI 모델\n\n로컬 도구로 처리합니다:\n\n```json5\n{\n  type: \"cli\",\n  command: \"whisper\",\n  args: [\"--model\", \"large-v3\", \"--output-format\", \"txt\", \"{{MediaPath}}\"],\n  maxChars: 0,             // 무제한\n  maxBytes: 20971520,      // 20MB\n  timeoutSeconds: 120,\n  capabilities: [\"audio\"],\n}\n```\n\n### CLI 템플릿 변수\n\n| 변수              | 설명                     |\n| ----------------- | ------------------------ |\n| `{{MediaPath}}`   | 입력 미디어 파일 경로    |\n| `{{MediaDir}}`    | 입력 파일 디렉토리       |\n| `{{OutputDir}}`   | 출력 디렉토리            |\n| `{{OutputBase}}`  | 확장자 없는 출력 파일명  |\n| `{{MaxChars}}`    | maxChars 값              |\n\n## 기본값과 제한\n\n| 미디어 타입 | maxChars 기본 | maxBytes 기본 |\n| ----------- | ------------- | ------------- |\n| **이미지**  | 500           | 10 MB         |\n| **오디오**  | 제한 없음     | 20 MB         |\n| **비디오**  | 500           | 50 MB         |\n\n## 자동 감지\n\n모델이 설정되지 않으면 자동으로 사용 가능한 프로바이더를 감지합니다:\n\n### 자동 감지 순서\n\n**오디오:**\n1. 로컬 CLI: `sherpa-onnx-offline`, `whisper-cli`, `whisper`\n2. Gemini CLI\n3. 프로바이더 키: OpenAI → Groq → Deepgram → Google\n\n**이미지:**\n1. 로컬 CLI \\(해당 시\\)\n2. Gemini CLI\n3. 프로바이더 키: OpenAI → Anthropic → Google → MiniMax\n\n**비디오:**\n1. Google \\(Gemini API\\)\n\n## 프로바이더 지원 매트릭스\n\n| 프로바이더     | 이미지 | 오디오 | 비디오 |\n| -------------- | ------ | ------ | ------ |\n| **OpenAI**     | ✅     | ✅     | —      |\n| **Anthropic**  | ✅     | —      | —      |\n| **Google**     | ✅     | ✅     | ✅     |\n| **Groq**       | —      | ✅     | —      |\n| **Deepgram**   | —      | ✅     | —      |\n| **MiniMax**    | ✅     | —      | —      |\n\n## 권장 프로바이더\n\n### 이미지\n\n```json5\n// 높은 품질\n{ provider: \"openai\", model: \"gpt-5.2\" }\n{ provider: \"anthropic\", model: \"claude-opus-4-6\" }\n\n// 빠른 처리\n{ provider: \"google\", model: \"gemini-3-flash-preview\" }\n```\n\n### 오디오\n\n```json5\n// 정확한 트랜스크립션\n{ provider: \"openai\", model: \"gpt-4o-mini-transcribe\" }\n{ provider: \"groq\", model: \"whisper-large-v3-turbo\" }\n\n// 실시간 스트리밍\n{ provider: \"deepgram\", model: \"nova-3\" }\n```\n\n### 비디오\n\n```json5\n// 유일한 옵션 \\(현재\\)\n{ provider: \"google\", model: \"gemini-3-flash-preview\" }\n{ provider: \"google\", model: \"gemini-3-pro-preview\" }\n```\n\n## 첨부 정책\n\n미디어 파일이 `maxBytes`를 초과하면 건너뜁니다. 상태 출력 예시:\n\n```\n📎 Media: image ok \\(openai/gpt-5.2\\) · audio skipped \\(maxBytes\\)\n```\n\n## 설정 예시\n\n### 이미지 + 오디오 통합 설정\n\n```json5\n{\n  tools: {\n    media: {\n      image: {\n        models: [\n          { provider: \"openai\", model: \"gpt-5.2\", maxChars: 500 },\n        ],\n      },\n      audio: {\n        models: [\n          { provider: \"groq\", model: \"whisper-large-v3-turbo\" },\n        ],\n      },\n    },\n  },\n}\n```\n\n### 로컬 Whisper + 프로바이더 폴백\n\n```json5\n{\n  tools: {\n    media: {\n      audio: {\n        models: [\n          {\n            type: \"cli\",\n            command: \"whisper-cli\",\n            args: [\"--model\", \"ggml-large-v3.bin\", \"-f\", \"{{MediaPath}}\"],\n            capabilities: [\"audio\"],\n          },\n          {\n            provider: \"openai\",\n            model: \"gpt-4o-mini-transcribe\",\n            capabilities: [\"audio\"],\n          },\n        ],\n      },\n    },\n  },\n}\n```\n\n## 상태 확인\n\n```bash\nopenclaw status --deep\n```\n\n미디어 이해 상태가 각 타입별로 표시됩니다.\n\n## 다음 단계\n\n- [노드 및 미디어]\\(/ko-KR/nodes\\) - 미디어 노드 개요\n- [설정 가이드]\\(/ko-KR/gateway/configuration\\) - 상세 설정 옵션\n- [모델 프로바이더]\\(/ko-KR/concepts/model-providers\\) - AI 모델 설정\nENDOFFILE)",
      "Bash(\"D:\\\\project\\\\openclaw\\\\docs\\\\ko-KR\\\\nodes\\\\talk.md\" << 'ENDOFFILE'\n---\nsummary: \"Talk 모드: ElevenLabs TTS를 사용한 연속 음성 대화\"\nread_when:\n  - Talk 모드를 설정하고 싶을 때\n  - 음성 대화 기능의 동작을 이해하고 싶을 때\n  - ElevenLabs TTS를 커스터마이징하고 싶을 때\ntitle: \"Talk 모드\"\n---\n\n# Talk 모드\n\nTalk 모드는 음성 인식과 ElevenLabs TTS를 결합하여 에이전트와 연속적인 음성 대화를 가능하게 합니다.\n\n## 동작 방식\n\n```mermaid\nflowchart LR\n    Listen[\"1. 음성 인식\\\\n\\(STT\\)\"] --> Send[\"2. 트랜스크립트\\\\n전송 \\(chat.send\\)\"]\n    Send --> Wait[\"3. 모델 응답\\\\n대기\"]\n    Wait --> Speak[\"4. TTS 재생\\\\n\\(ElevenLabs\\)\"]\n    Speak --> Listen\n```\n\n1. **듣기**: 마이크에서 음성을 인식\n2. **전송**: 트랜스크립트를 메인 세션의 `chat.send`로 전송\n3. **대기**: 모델의 응답을 기다림\n4. **말하기**: ElevenLabs를 통해 스트리밍 TTS 재생\n\n대화가 끝나면 다시 듣기 상태로 돌아갑니다.\n\n## 설정\n\n```json5\n{\n  talk: {\n    voiceId: \"elevenlabs_voice_id\",\n    modelId: \"eleven_v3\",\n    outputFormat: \"mp3_44100_128\",\n    apiKey: \"elevenlabs_api_key\",\n    interruptOnSpeech: true,\n  },\n}\n```\n\n### 설정 항목\n\n| 항목                | 기본값                          | 설명                           |\n| ------------------- | ------------------------------- | ------------------------------ |\n| `voiceId`           | 환경 변수에서                   | ElevenLabs 음성 ID             |\n| `modelId`           | `eleven_v3`                     | TTS 모델                       |\n| `outputFormat`      | `pcm_44100` \\(macOS/iOS\\)        | 오디오 출력 형식               |\n| `apiKey`            | 환경 변수에서                   | ElevenLabs API 키              |\n| `interruptOnSpeech` | `true`                          | 말하는 중 새 음성 감지 시 중단 |\n\n### 환경 변수 폴백\n\n| 설정       | 환경 변수                                    |\n| ---------- | -------------------------------------------- |\n| `voiceId`  | `ELEVENLABS_VOICE_ID` 또는 `SAG_VOICE_ID`   |\n| `apiKey`   | `ELEVENLABS_API_KEY`                         |\n\n### 플랫폼별 기본 출력 형식\n\n| 플랫폼      | 기본 출력 형식    |\n| ----------- | ----------------- |\n| **macOS**   | `pcm_44100`       |\n| **iOS**     | `pcm_44100`       |\n| **Android** | `pcm_24000`       |\n\n## 음성 디렉티브\n\n에이전트가 응답의 첫 줄에 JSON 디렉티브를 포함하여 음성 설정을 동적으로 변경할 수 있습니다:\n\n```json\n{ \"voice\": \"voice-id-here\", \"once\": true }\n```\n\n### 지원 키\n\n| 키               | 설명                           |\n| ---------------- | ------------------------------ |\n| `voice`          | ElevenLabs 음성 ID             |\n| `model`          | TTS 모델 ID                   |\n| `speed`          | 재생 속도                      |\n| `rate`           | 분당 단어 수 \\(WPM\\)            |\n| `stability`      | 음성 안정성 \\(0~1\\)             |\n| `similarity`     | 원본 유사도 \\(0~1\\)             |\n| `style`          | 스타일 강도 \\(0~1\\)             |\n| `speakerBoost`   | 스피커 부스트                  |\n| `seed`           | 랜덤 시드                      |\n| `normalize`      | 볼륨 정규화                    |\n| `lang`           | 언어 코드                      |\n| `output_format`  | 출력 형식                      |\n| `latency_tier`   | 지연 시간 티어                 |\n| `once`           | `true`이면 이번 응답에만 적용  |\n\n### 음성 디렉티브 예시\n\n```json\n{ \"voice\": \"rachel\", \"stability\": 0.8, \"similarity\": 0.7 }\n```\n\n에이전트 AGENTS.md에서 지시할 수 있습니다:\n\n```markdown\n## 음성 응답 규칙\n한국어로 응답할 때는 첫 줄에 다음을 포함하세요:\n{ \"voice\": \"korean-voice-id\", \"lang\": \"ko\" }\n```\n\n## macOS UI\n\n### 활성화\n\n- 메뉴 바에서 **Talk** 토글\n- 또는 설정 → **Talk Mode** 그룹\n\n### 오버레이 상태\n\n| 상태        | 표시      | 설명                     |\n| ----------- | --------- | ------------------------ |\n| **Listening**  | 🎙️ 파란색 | 음성 입력 대기 중        |\n| **Thinking**   | 🧠 노란색 | 모델 응답 처리 중        |\n| **Speaking**   | 🔊 초록색 | TTS 재생 중              |\n\n### 중단 \\(Interrupt\\)\n\n`interruptOnSpeech: true` \\(기본\\)일 때:\n\n1. 에이전트가 말하는 중에 사용자가 다시 말하면\n2. TTS 재생을 즉시 중단\n3. 새 입력으로 전환\n\n## ElevenLabs 설정 팁\n\n### 음성 선택\n\n1. [ElevenLabs Voice Library]\\(https://elevenlabs.io/voice-library\\)에서 음성 탐색\n2. 원하는 음성의 ID를 복사\n3. `talk.voiceId`에 설정\n\n### 모델 선택\n\n| 모델              | 특성                      |\n| ----------------- | ------------------------- |\n| `eleven_v3`       | 최신, 고품질 \\(기본\\)       |\n| `eleven_turbo_v2` | 빠른 응답, 약간 낮은 품질 |\n| `eleven_v2`       | 안정적, 레거시            |\n\n### 비용 최적화\n\n- Talk 모드는 TTS API 호출이 빈번합니다\n- 짧은 응답을 유도하면 비용을 절감할 수 있습니다\n- AGENTS.md에 \"음성 대화 시 간결하게 응답\" 지침을 추가하세요\n\n## 문제 해결\n\n| 증상                    | 해결                                    |\n| ----------------------- | --------------------------------------- |\n| 음성이 재생되지 않음    | ElevenLabs API 키와 음성 ID 확인       |\n| 인식이 잘 안 됨         | 마이크 권한 확인, 조용한 환경 확인      |\n| 지연 시간이 김          | `eleven_turbo_v2` 모델 사용 고려       |\n| 중단이 작동하지 않음    | `interruptOnSpeech: true` 확인         |\n\n## 다음 단계\n\n- [음성 웨이크]\\(/ko-KR/nodes/voicewake\\) - 웨이크 워드 설정\n- [미디어 이해]\\(/ko-KR/nodes/media-understanding\\) - 오디오 트랜스크립션\n- [노드 및 미디어]\\(/ko-KR/nodes\\) - 노드 개요\nENDOFFILE)",
      "Bash(\"D:\\\\project\\\\openclaw\\\\docs\\\\ko-KR\\\\automation\\\\cron-vs-heartbeat.md\" << 'ENDOFFILE'\n---\nsummary: \"하트비트와 크론 작업 중 어떤 것을 선택할지 가이드\"\nread_when:\n  - 반복 작업의 스케줄링 방법을 결정하고 싶을 때\n  - 하트비트와 크론의 차이를 이해하고 싶을 때\n  - 백그라운드 모니터링을 설정하고 싶을 때\ntitle: \"크론 vs 하트비트\"\n---\n\n# 크론 vs 하트비트\n\n반복 작업을 자동화할 때 **하트비트**와 **크론 작업** 중 어떤 것을 사용할지 가이드합니다.\n\n## 빠른 결정 가이드\n\n| 사용 사례                   | 권장          | 이유                                |\n| --------------------------- | ------------- | ----------------------------------- |\n| 30분마다 받은편지함 확인    | **하트비트**  | 다른 점검과 함께 배치 처리          |\n| 매일 오전 9시 리포트 전송   | **크론 \\(격리\\)** | 정확한 타이밍 필요                 |\n| 캘린더 모니터링             | **하트비트**  | 주기적 인식에 자연스러운 적합       |\n| 주간 심층 분석 실행         | **크론 \\(격리\\)** | 독립 작업, 다른 모델 사용 가능     |\n| 20분 후 알림                | **크론 \\(메인, `--at`\\)** | 일회성, 정확한 타이밍        |\n| 백그라운드 프로젝트 상태 점검| **하트비트**  | 기존 사이클에 편승                  |\n\n## 하트비트: 주기적 인식\n\n하트비트는 에이전트가 **주기적으로 깨어나** HEARTBEAT.md의 지침을 수행합니다.\n\n### 특성\n\n- 메인 세션 안에서 실행 \\(전체 히스토리 접근\\)\n- 일정 간격으로 자동 트리거\n- 여러 점검 항목을 한 번에 배치 처리\n- 정확한 시간 보장 없음 \\(대략적인 간격\\)\n\n### 설정\n\n```json5\n{\n  agents: {\n    defaults: {\n      heartbeat: {\n        every: \"30m\",\n        target: \"last\",\n        activeHours: { start: \"08:00\", end: \"22:00\" },\n      },\n    },\n  },\n}\n```\n\n### 적합한 경우\n\n- 여러 점검을 배치로 수행할 때\n- 메인 세션 컨텍스트가 필요할 때\n- 정확한 실행 시간이 중요하지 않을 때\n- 별도 세션/모델이 필요 없을 때\n\n## 크론: 정밀 스케줄링\n\n크론 작업은 **정확한 시간**에 실행되며, 격리된 세션이나 메인 세션에서 동작합니다.\n\n### 특성\n\n- 정확한 시간에 트리거 \\(cron 표현식 / `--at` 단일 지연\\)\n- 격리 세션: 매 실행마다 깨끗한 상태\n- 메인 세션: 시스템 이벤트로 주입\n- 모델, thinking 레벨 오버라이드 가능\n\n### 크론 작업 추가 예시\n\n**반복 작업 \\(격리 세션\\):**\n\n```bash\nopenclaw cron add \\\\\n  --name \"Morning briefing\" \\\\\n  --cron \"0 7 * * *\" \\\\\n  --tz \"Asia/Seoul\" \\\\\n  --session isolated \\\\\n  --message \"오늘의 브리핑을 생성하세요...\" \\\\\n  --model opus \\\\\n  --announce \\\\\n  --channel whatsapp \\\\\n  --to \"+821012345678\"\n```\n\n**일회성 알림 \\(메인 세션\\):**\n\n```bash\nopenclaw cron add \\\\\n  --name \"Meeting reminder\" \\\\\n  --at \"20m\" \\\\\n  --session main \\\\\n  --system-event \"알림: 스탠드업 미팅이 10분 후 시작됩니다.\" \\\\\n  --wake now \\\\\n  --delete-after-run\n```\n\n### 적합한 경우\n\n- 정확한 실행 시간이 필요할 때\n- 메인 세션과 격리가 필요할 때\n- 다른 모델이나 thinking 레벨을 사용하고 싶을 때\n- 실행 결과를 특정 채널로 전달하고 싶을 때\n\n## 결정 플로우차트\n\n```mermaid\nflowchart TD\n    Start[\"반복 작업\"] --> ExactTime{\"정확한\\\\n실행 시간\\\\n필요?\"}\n    ExactTime -->|예| Cron1[\"크론 사용\"]\n    ExactTime -->|아니오| Isolation{\"메인 세션과\\\\n격리 필요?\"}\n    Isolation -->|예| Cron2[\"크론 \\(격리\\) 사용\"]\n    Isolation -->|아니오| Batch{\"다른 점검과\\\\n배치 가능?\"}\n    Batch -->|예| HB[\"하트비트 사용\"]\n    Batch -->|아니오| OneShot{\"일회성\\\\n알림?\"}\n    OneShot -->|예| CronAt[\"크론 --at 사용\"]\n    OneShot -->|아니오| DiffModel{\"다른 모델/\\\\nthinking?\"}\n    DiffModel -->|예| Cron3[\"크론 \\(격리\\) 사용\"]\n    DiffModel -->|아니오| HB2[\"하트비트 사용\"]\n```\n\n## 두 가지 조합\n\n하트비트와 크론을 함께 사용할 수 있습니다:\n\n```json5\n{\n  agents: {\n    defaults: {\n      heartbeat: {\n        every: \"30m\",             // 기본 모니터링\n      },\n    },\n  },\n}\n```\n\n```bash\n# 매일 오전 9시 별도 리포트\nopenclaw cron add \\\\\n  --name \"Daily report\" \\\\\n  --cron \"0 9 * * *\" \\\\\n  --session isolated \\\\\n  --model sonnet \\\\\n  --message \"어제 활동 요약 리포트를 작성하세요\"\n```\n\n## 세션 비교\n\n|                | 하트비트         | 크론 \\(메인\\)              | 크론 \\(격리\\)            |\n| -------------- | ---------------- | ------------------------ | ---------------------- |\n| **세션**       | 메인             | 메인 \\(시스템 이벤트\\)     | `cron:<jobId>`         |\n| **히스토리**   | 공유             | 공유                     | 매 실행마다 초기화     |\n| **컨텍스트**   | 전체             | 전체                     | 없음 \\(깨끗한 시작\\)    |\n| **모델**       | 메인 세션 모델   | 메인 세션 모델           | 오버라이드 가능        |\n| **출력**       | HEARTBEAT_OK 아닐 때 | 하트비트 프롬프트 + 이벤트 | announce 요약       |\n\n## 비용 고려사항\n\n| 방식             | 비용 특성                                    |\n| ---------------- | -------------------------------------------- |\n| **하트비트**     | N분마다 1턴; HEARTBEAT.md 크기에 비례        |\n| **크론 \\(메인\\)**  | 다음 하트비트에 이벤트 추가 \\(별도 턴 없음\\)   |\n| **크론 \\(격리\\)**  | 작업당 전체 에이전트 턴; 저렴한 모델 사용 가능 |\n\n### 비용 최적화 팁\n\n- 하트비트의 HEARTBEAT.md를 간결하게 유지\n- 비용이 중요한 격리 크론은 저렴한 모델 사용 \\(`--model haiku`\\)\n- 메인 세션 크론은 별도 비용이 거의 없음\n\n## 다음 단계\n\n- [하트비트]\\(/ko-KR/gateway/heartbeat\\) - 하트비트 상세 설정\n- [자동화]\\(/ko-KR/automation\\) - 크론 작업 관리\n- [훅]\\(/ko-KR/automation/hooks\\) - 이벤트 기반 자동화\nENDOFFILE)",
      "Bash(\"D:\\\\project\\\\openclaw\\\\docs\\\\ko-KR\\\\web\\\\dashboard.md\" << 'ENDOFFILE'\n---\nsummary: \"Gateway 대시보드 \\(Control UI\\) 접근과 인증\"\nread_when:\n  - 대시보드에 접근하고 싶을 때\n  - 대시보드 인증을 설정하고 싶을 때\n  - unauthorized 오류를 해결하고 싶을 때\ntitle: \"대시보드\"\n---\n\n# 대시보드\n\nGateway 대시보드\\(Control UI\\)는 브라우저에서 채팅, 설정, 세션, 노드를 관리하는 웹 인터페이스입니다.\n\n## 빠른 열기\n\n로컬 Gateway가 실행 중일 때:\n\n```bash\nopenclaw dashboard\n```\n\n이 명령어는:\n1. 대시보드 링크를 클립보드에 복사\n2. 기본 브라우저에서 열기\n3. 헤드리스 서버에서는 SSH 힌트 표시\n\n### 기본 접근 URL\n\n```\nhttp://127.0.0.1:18789/\n```\n\n또는:\n\n```\nhttp://localhost:18789/\n```\n\n### 커스텀 기본 경로\n\n```json5\n{\n  gateway: {\n    controlUi: {\n      basePath: \"/admin\",  // http://127.0.0.1:18789/admin/\n    },\n  },\n}\n```\n\n## 주요 참조 명령어\n\n| 명령어                                        | 설명                          |\n| --------------------------------------------- | ----------------------------- |\n| `openclaw dashboard`                          | 대시보드 열기                 |\n| `openclaw status`                             | Gateway 접근 가능 여부 확인   |\n| `openclaw config get gateway.auth.token`      | 현재 토큰 조회                |\n| `openclaw doctor --generate-gateway-token`    | 새 토큰 생성                  |\n\n## 인증\n\n대시보드 인증은 **WebSocket 핸드셰이크** 시점에 `connect.params.auth`로 수행됩니다.\n\n### 인증 방식\n\n| 방식      | 설명                           |\n| --------- | ------------------------------ |\n| **토큰**  | `gateway.auth.token` 값 사용  |\n| **비밀번호** | `gateway.auth.password` 사용 |\n\n### 설정\n\n```json5\n{\n  gateway: {\n    auth: {\n      token: \"your-secure-token\",\n      // 또는\n      password: \"your-password\",\n    },\n  },\n}\n```\n\n### 빠른 경로 \\(권장\\)\n\n1. `openclaw doctor --generate-gateway-token` 실행\n2. 생성된 토큰이 자동으로 설정에 저장됨\n3. 대시보드에서 토큰을 입력하여 연결\n\n### 토큰 기본 동작\n\n| 환경      | 토큰 필요 여부 | 설명                          |\n| --------- | -------------- | ----------------------------- |\n| **로컬**  | 선택           | localhost에서는 토큰 없이 가능 |\n| **원격**  | 필수           | SSH 터널이나 Tailscale 통해   |\n\n## UI 토큰 저장\n\n대시보드는 처음 연결 시 입력한 토큰을 브라우저의 `localStorage`에 저장합니다. 이후 접속 시 자동으로 사용됩니다.\n\n## 보안 권장 사항\n\nControl UI는 **관리자 화면**입니다. 다음 기능에 접근할 수 있습니다:\n\n- 채팅 \\(에이전트와 대화\\)\n- 설정 변경\n- exec 승인 \\(명령어 실행 허용\\)\n- 세션 관리\n- 노드 페어링\n\n### 보안 규칙\n\n| 규칙                         | 권장                              |\n| ---------------------------- | --------------------------------- |\n| **공개 인터넷에 노출하지 마세요** | ❌ 절대 하지 마세요           |\n| **localhost 사용**           | ✅ 가장 안전                      |\n| **Tailscale Serve**          | ✅ 편리한 보안 원격 접근          |\n| **SSH 터널**                 | ✅ 원격 접근 시 권장              |\n| **토큰 설정**                | ✅ 원격 접근 시 필수              |\n\n## 문제 해결\n\n### \"unauthorized\" / 1008 오류\n\nWebSocket 연결이 거부될 때:\n\n1. **토큰 확인**: `openclaw config get gateway.auth.token`\n2. **Gateway 실행 확인**: `openclaw status`\n3. **토큰 재생성**: `openclaw doctor --generate-gateway-token`\n4. **브라우저 캐시 정리**: localStorage에 저장된 이전 토큰이 유효하지 않을 수 있음\n\n### Gateway에 연결할 수 없음\n\n```bash\n# Gateway 상태 확인\nopenclaw status\n\n# 포트 사용 확인\nopenclaw status --deep\n\n# 전체 진단\nopenclaw doctor\n```\n\n### 원격에서 접근할 수 없음\n\n1. SSH 터널이 활성인지 확인\n2. 토큰이 설정되었는지 확인\n3. 방화벽 규칙 확인\n4. [원격 접근]\\(/ko-KR/gateway/remote\\) 가이드 참조\n\n## 다음 단계\n\n- [웹 인터페이스]\\(/ko-KR/web\\) - Control UI 전체 기능\n- [원격 접근]\\(/ko-KR/gateway/remote\\) - 원격 대시보드 접근\n- [보안]\\(/ko-KR/gateway/security\\) - Gateway 보안 설정\n- [Tailscale]\\(/ko-KR/gateway/tailscale\\) - Tailscale 통합\nENDOFFILE)",
      "Bash(\"D:\\\\project\\\\openclaw\\\\docs\\\\ko-KR\\\\help\\\\environment.md\" << 'ENDOFFILE'\n---\nsummary: \"환경 변수 로딩 위치와 우선순위\"\nread_when:\n  - 어떤 환경 변수가 로드되는지 알고 싶을 때\n  - API 키가 인식되지 않는 문제를 디버깅할 때\n  - 프로바이더 인증 설정을 확인하고 싶을 때\ntitle: \"환경 변수\"\n---\n\n# 환경 변수\n\nOpenClaw가 환경 변수를 로드하는 위치와 우선순위를 설명합니다.\n\n## 우선순위 \\(높은 것 → 낮은 것\\)\n\n```mermaid\nflowchart TD\n    P1[\"1. 프로세스 환경\\\\n\\(부모 셸/데몬\\)\"] --> P2[\"2. .env \\(현재 디렉토리\\)\\\\n\\(dotenv, 덮어쓰지 않음\\)\"]\n    P2 --> P3[\"3. 글로벌 .env\\\\n\\(~/.openclaw/.env\\)\"]\n    P3 --> P4[\"4. Config env 블록\\\\n\\(openclaw.json\\)\"]\n    P4 --> P5[\"5. 로그인 셸 임포트\\\\n\\(선택적\\)\"]\n```\n\n| 우선순위 | 소스                          | 동작                              |\n| -------- | ----------------------------- | --------------------------------- |\n| **1**    | 프로세스 환경 \\(부모 셸/데몬\\)  | 항상 최우선                       |\n| **2**    | `.env` \\(현재 작업 디렉토리\\)   | dotenv 기본; 기존 값 덮어쓰지 않음 |\n| **3**    | `~/.openclaw/.env` \\(글로벌\\)   | 기존 값 덮어쓰지 않음            |\n| **4**    | Config `env` 블록             | 값이 없을 때만 설정              |\n| **5**    | 로그인 셸 임포트 \\(선택\\)       | `env.shellEnv.enabled` 필요      |\n\n## Config `env` 블록\n\n`~/.openclaw/openclaw.json`에서 직접 환경 변수를 설정합니다:\n\n```json5\n{\n  env: {\n    OPENROUTER_API_KEY: \"sk-or-...\",\n    vars: {\n      GROQ_API_KEY: \"gsk-...\",\n    },\n  },\n}\n```\n\n- 최상위 키 \\(`OPENROUTER_API_KEY`\\)와 `vars` 내부 키 모두 지원\n- 이미 프로세스 환경이나 `.env`에 설정된 값은 덮어쓰지 않음\n\n## 셸 환경 임포트\n\n로그인 셸에서 환경 변수를 가져오는 선택적 기능입니다:\n\n```json5\n{\n  env: {\n    shellEnv: {\n      enabled: true,\n      timeoutMs: 15000,  // 셸 시작 타임아웃 \\(기본: 15초\\)\n    },\n  },\n}\n```\n\n### 환경 변수로 활성화\n\n```bash\nOPENCLAW_LOAD_SHELL_ENV=1 openclaw gateway\nOPENCLAW_SHELL_ENV_TIMEOUT_MS=15000\n```\n\n### 동작 방식\n\n1. OpenClaw가 로그인 셸을 시작 \\(`bash -l` 또는 `zsh -l`\\)\n2. 셸의 환경 변수를 추출\n3. 아직 설정되지 않은 변수를 프로세스에 추가\n4. `~/.profile`, `~/.bash_profile`, `~/.zshrc` 등에서 export된 변수 포함\n\n### 사용 시기\n\n- 데몬으로 실행할 때 `~/.profile`의 API 키가 필요한 경우\n- nvm, pyenv 등 셸 초기화가 필요한 경우\n\n## .env 파일\n\n### 현재 디렉토리 .env\n\n프로젝트별 환경 변수:\n\n```bash\n# /path/to/project/.env\nANTHROPIC_API_KEY=sk-ant-...\nOPENAI_API_KEY=sk-...\n```\n\n### 글로벌 .env\n\n모든 세션에 적용:\n\n```bash\n# ~/.openclaw/.env\nANTHROPIC_API_KEY=sk-ant-...\nELEVENLABS_API_KEY=...\nDEEPGRAM_API_KEY=...\n```\n\n## Config에서 환경 변수 치환\n\n설정 파일에서 `${VAR_NAME}` 구문으로 환경 변수를 참조할 수 있습니다:\n\n```json5\n{\n  models: {\n    providers: {\n      \"vercel-gateway\": {\n        apiKey: \"${VERCEL_GATEWAY_API_KEY}\",\n      },\n    },\n  },\n}\n```\n\n이 치환은 설정 파일 로딩 시 수행되며, 위의 우선순위에 따라 환경 변수가 해석됩니다.\n\n## 주요 환경 변수 목록\n\n### API 키\n\n| 변수                    | 설명                     |\n| ----------------------- | ------------------------ |\n| `ANTHROPIC_API_KEY`     | Anthropic API 키         |\n| `OPENAI_API_KEY`        | OpenAI API 키            |\n| `GOOGLE_API_KEY`        | Google AI API 키         |\n| `GROQ_API_KEY`          | Groq API 키              |\n| `DEEPGRAM_API_KEY`      | Deepgram API 키          |\n| `ELEVENLABS_API_KEY`    | ElevenLabs API 키        |\n| `OPENROUTER_API_KEY`    | OpenRouter API 키        |\n\n### OpenClaw 설정\n\n| 변수                          | 설명                          |\n| ----------------------------- | ----------------------------- |\n| `OPENCLAW_PROFILE`            | 프로필 이름 \\(워크스페이스 분리\\) |\n| `OPENCLAW_DISABLE_BONJOUR`    | Bonjour 비활성화              |\n| `OPENCLAW_SSH_PORT`           | SSH 포트                      |\n| `OPENCLAW_TAILNET_DNS`        | Tailscale DNS                 |\n| `OPENCLAW_CLI_PATH`           | CLI 경로                      |\n| `OPENCLAW_LOAD_SHELL_ENV`     | 셸 환경 임포트 활성화         |\n| `OPENCLAW_GATEWAY_URL`        | Gateway URL \\(원격\\)            |\n| `OPENCLAW_GATEWAY_TOKEN`      | Gateway 토큰 \\(원격\\)          |\n\n### 디버깅\n\n| 변수                    | 설명                          |\n| ----------------------- | ----------------------------- |\n| `OPENCLAW_DEBUG`        | 디버그 모드 활성화            |\n| `OPENCLAW_LOG_LEVEL`    | 로그 레벨 \\(debug/info/warn\\)  |\n| `OPENCLAW_LIVE_TEST`    | 라이브 테스트 활성화          |\n\n## 문제 해결\n\n### API 키가 인식되지 않음\n\n1. 우선순위 확인: 프로세스 환경 > .env > config\n2. `.env` 파일 위치 확인 \\(현재 디렉토리 또는 `~/.openclaw/`\\)\n3. Config `env` 블록에 설정되었는지 확인\n4. `openclaw doctor`로 진단\n\n### 셸 환경 변수가 로드되지 않음\n\n1. `env.shellEnv.enabled: true` 확인\n2. `~/.profile`에서 해당 변수가 `export` 되었는지 확인\n3. 타임아웃 증가: `shellEnv.timeoutMs: 30000`\n4. 셸 로그인 스크립트에 오류가 없는지 확인\n\n## 다음 단계\n\n- [설정 가이드]\\(/ko-KR/gateway/configuration\\) - 전체 설정 옵션\n- [모델 프로바이더]\\(/ko-KR/concepts/model-providers\\) - 프로바이더별 인증\n- [디버깅]\\(/ko-KR/help/debugging\\) - 환경 변수 디버깅\n- [FAQ]\\(/ko-KR/help/faq\\) - 환경 변수 관련 FAQ\nENDOFFILE)",
      "Bash(\"D:\\\\project\\\\openclaw\\\\docs\\\\ko-KR\\\\help\\\\testing.md\" << 'ENDOFFILE'\n---\nsummary: \"테스트 킷: 단위/E2E/라이브 테스트 스위트와 실행 방법\"\nread_when:\n  - 테스트를 로컬이나 CI에서 실행하고 싶을 때\n  - 모델/프로바이더 회귀 테스트를 추가하고 싶을 때\n  - Gateway와 에이전트 동작을 디버깅하고 싶을 때\ntitle: \"테스팅\"\n---\n\n# 테스팅\n\nOpenClaw의 테스트 스위트 구성, 실행 방법, 그리고 회귀 테스트 추가 가이드입니다.\n\n## 빠른 시작\n\n```bash\npnpm build && pnpm check && pnpm test   # 전체 게이트 \\(push 전 권장\\)\npnpm test:coverage                       # 커버리지 게이트\npnpm test:e2e                            # E2E 스위트\npnpm test:live                           # 라이브 스위트 \\(실제 자격 증명 필요\\)\n```\n\n## 테스트 스위트\n\n### 단위/통합 테스트 \\(기본\\)\n\n| 항목        | 값                        |\n| ----------- | ------------------------- |\n| **명령어**  | `pnpm test`               |\n| **설정**    | `vitest.config.ts`        |\n| **파일**    | `src/**/*.test.ts`        |\n| **범위**    | 순수 단위 테스트, 인프로세스 통합 테스트, 결정적 회귀 |\n| **요구사항** | CI 실행 가능, 실제 키 불필요, 빠르고 안정적 |\n\n### E2E 테스트 \\(Gateway 스모크\\)\n\n| 항목        | 값                        |\n| ----------- | ------------------------- |\n| **명령어**  | `pnpm test:e2e`           |\n| **설정**    | `vitest.e2e.config.ts`    |\n| **파일**    | `src/**/*.e2e.test.ts`    |\n| **범위**    | 멀티 인스턴스 Gateway E2E, WebSocket/HTTP 서피스, 노드 페어링 |\n| **요구사항** | CI 실행 가능, 실제 키 불필요, 상대적으로 느림 |\n\n### 라이브 테스트 \\(실제 프로바이더\\)\n\n| 항목        | 값                        |\n| ----------- | ------------------------- |\n| **명령어**  | `pnpm test:live`          |\n| **설정**    | `vitest.live.config.ts`   |\n| **파일**    | `src/**/*.live.test.ts`   |\n| **활성화**  | `OPENCLAW_LIVE_TEST=1` \\(pnpm test:live가 자동 설정\\) |\n| **범위**    | 실제 자격 증명으로 프로바이더/모델 동작 확인 |\n| **요구사항** | CI 불안정 \\(실제 네트워크\\), 비용 발생, 좁은 범위 권장 |\n\n## 어떤 스위트를 실행할까?\n\n| 상황                           | 스위트                |\n| ------------------------------ | --------------------- |\n| 코드 변경 후 빠른 검증         | `pnpm test`           |\n| Gateway 통합 확인              | `pnpm test:e2e`       |\n| 특정 프로바이더 동작 확인      | `pnpm test:live`      |\n| push 전 전체 검증              | `pnpm build && pnpm check && pnpm test` |\n| 커버리지 확인                  | `pnpm test:coverage`  |\n\n## 라이브 테스트: 모델 스모크\n\n### 레이어 1: 직접 모델 완성\n\n```bash\n# 단일 모델 테스트\nOPENCLAW_LIVE_MODELS=\"openai/gpt-5.2\" \\\\\n  pnpm test:live src/agents/models.profiles.live.test.ts\n```\n\n- **테스트 파일**: `src/agents/models.profiles.live.test.ts`\n- **목적**: 발견된 모델을 나열하고, 모델별 소규모 완성 실행\n- **활성화**: `OPENCLAW_LIVE_MODELS=modern` \\(또는 `all`\\)\n- **Modern 허용 목록**: Opus/Sonnet/Haiku 4.5, GPT-5.x + Codex, Gemini 3, GLM 4.7, MiniMax M2.1, Grok 4\n\n### 레이어 2: Gateway + Dev 에이전트 스모크\n\n```bash\n# 단일 모델, Gateway 스모크\nOPENCLAW_LIVE_GATEWAY_MODELS=\"openai/gpt-5.2\" \\\\\n  pnpm test:live src/gateway/gateway-models.profiles.live.test.ts\n```\n\n- **테스트 파일**: `src/gateway/gateway-models.profiles.live.test.ts`\n- **목적**: 인프로세스 Gateway 시작, `agent:dev` 세션 생성, 키가 있는 모델 반복\n- **검증**: 의미 있는 응답 \\(도구 없음\\), 실제 도구 호출\n- **프로브 유형**: `read` 프로브, `exec+read` 프로브, 이미지 프로브\n\n### 키 소싱\n\n라이브 테스트는 CLI와 동일한 방식으로 자격 증명을 찾습니다:\n\n| 소스                              | 설명                    |\n| --------------------------------- | ----------------------- |\n| `~/.openclaw/credentials/`        | 프로필 스토어 \\(선호\\)    |\n| `~/.openclaw/openclaw.json`       | Config 파일             |\n| `~/.profile`                      | 누락된 API 키 폴백     |\n\n**Anthropic 키:**\n\n```bash\nOPENCLAW_LIVE_ANTHROPIC_KEYS=\"sk-...,sk-...\"   # 여러 키 \\(콤마 구분\\)\nOPENCLAW_LIVE_ANTHROPIC_KEY=sk-...              # 단일 키\n```\n\n## 라이브: Setup-Token 스모크\n\n```bash\nOPENCLAW_LIVE_SETUP_TOKEN=1 \\\\\nOPENCLAW_LIVE_SETUP_TOKEN_PROFILE=anthropic:setup-token-test \\\\\nOPENCLAW_LIVE_SETUP_TOKEN_VALUE=sk-ant-oat01-... \\\\\n  pnpm test:live src/agents/anthropic.setup-token.live.test.ts\n```\n\n## 라이브: CLI 백엔드 스모크\n\n```bash\nOPENCLAW_LIVE_CLI_BACKEND=1 \\\\\n  pnpm test:live src/gateway/gateway-cli-backend.live.test.ts\n```\n\n| 오버라이드                                 | 기본값                             |\n| ------------------------------------------ | ---------------------------------- |\n| `OPENCLAW_LIVE_CLI_BACKEND_MODEL`          | `claude-cli/claude-sonnet-4-5`     |\n| `OPENCLAW_LIVE_CLI_BACKEND_COMMAND`        | `claude`                           |\n| `OPENCLAW_LIVE_CLI_BACKEND_IMAGE_PROBE`    | `0`                                |\n| `OPENCLAW_LIVE_CLI_BACKEND_RESUME_PROBE`   | `0`                                |\n\n## 권장 라이브 레시피\n\n### 단일 모델 \\(직접\\)\n\n```bash\nOPENCLAW_LIVE_MODELS=\"openai/gpt-5.2\" \\\\\n  pnpm test:live src/agents/models.profiles.live.test.ts\n```\n\n### 단일 모델 \\(Gateway 스모크\\)\n\n```bash\nOPENCLAW_LIVE_GATEWAY_MODELS=\"openai/gpt-5.2\" \\\\\n  pnpm test:live src/gateway/gateway-models.profiles.live.test.ts\n```\n\n### 프로바이더 간 도구 호출\n\n```bash\nOPENCLAW_LIVE_GATEWAY_MODELS=\"openai/gpt-5.2,anthropic/claude-opus-4-6,google/gemini-3-flash-preview,zai/glm-4.7,minimax/minimax-m2.1\" \\\\\n  pnpm test:live src/gateway/gateway-models.profiles.live.test.ts\n```\n\n### Google 포커스\n\n```bash\n# Gemini API\nOPENCLAW_LIVE_GATEWAY_MODELS=\"google/gemini-3-flash-preview\" pnpm test:live\n\n# Antigravity\nOPENCLAW_LIVE_GATEWAY_MODELS=\"google-antigravity/claude-opus-4-6-thinking,google-antigravity/gemini-3-pro-high\" pnpm test:live\n```\n\n## Docker 러너\n\n| 명령어                              | 설명                            |\n| ----------------------------------- | ------------------------------- |\n| `pnpm test:docker:live-models`      | 직접 모델 테스트                |\n| `pnpm test:docker:live-gateway`     | Gateway + dev 에이전트          |\n| `pnpm test:docker:onboard`          | 온보딩 마법사 \\(TTY\\)             |\n| `pnpm test:docker:gateway-network`  | 두 컨테이너, WS 인증 + 헬스    |\n| `pnpm test:docker:plugins`          | 커스텀 확장 로드 + 레지스트리   |\n\n### Docker 환경 변수\n\n| 변수                                 | 기본값                   |\n| ------------------------------------ | ------------------------ |\n| `OPENCLAW_CONFIG_DIR`                | `~/.openclaw`            |\n| `OPENCLAW_WORKSPACE_DIR`             | `~/.openclaw/workspace`  |\n| `OPENCLAW_PROFILE_FILE`              | `~/.profile`             |\n| `OPENCLAW_LIVE_GATEWAY_MODELS`       | —                        |\n| `OPENCLAW_LIVE_REQUIRE_PROFILE_KEYS` | —                        |\n\n## 문서 검증\n\n```bash\npnpm docs:list\n```\n\n문서 파일의 기본 구조와 링크를 확인합니다.\n\n## Deepgram 라이브 테스트\n\n```bash\nDEEPGRAM_API_KEY=... DEEPGRAM_LIVE_TEST=1 \\\\\n  pnpm test:live src/media-understanding/providers/deepgram/audio.live.test.ts\n```\n\n## 자격 증명 관리\n\n> ⚠️ 자격 증명을 절대 커밋하지 마세요\n\n| 방법                       | 위치                         |\n| -------------------------- | ---------------------------- |\n| **프로필 스토어** \\(선호\\)   | `~/.openclaw/credentials/`   |\n| **Config 파일**            | `~/.openclaw/openclaw.json`  |\n| **환경 변수**              | `~/.profile`에서 export      |\n\n## 오프라인 회귀 \\(CI 안전\\)\n\nCI에서 안전하게 실행할 수 있는 회귀 테스트:\n\n- **모의 도구 호출**: `src/gateway/gateway.tool-calling.mock-openai.test.ts`\n- **Gateway 마법사**: `src/gateway/gateway.wizard.e2e.test.ts`\n\n## 회귀 테스트 추가 가이드\n\n### 원칙\n\n1. **CI 안전 회귀 선호**: 모의/스텁 프로바이더로 정확한 요청 변환 캡처\n2. **라이브 테스트는 좁은 범위**: opt-in 환경 변수로 제한\n3. **가장 작은 레이어 대상**:\n   - 프로바이더 요청 변환 → 직접 모델 테스트\n   - Gateway 세션/히스토리/도구 파이프라인 → Gateway 라이브 스모크 또는 CI 안전 모의 테스트\n\n### 버그 유형별 테스트 위치\n\n| 버그 유형                    | 테스트 위치                    |\n| ---------------------------- | ------------------------------ |\n| 프로바이더 API 요청 포맷     | `*.test.ts` \\(단위\\)            |\n| 도구 호출 파이프라인         | `*.e2e.test.ts` 또는 모의     |\n| 특정 모델의 응답 처리        | `*.live.test.ts`              |\n| Gateway WebSocket 처리       | `*.e2e.test.ts`               |\n\n## 다음 단계\n\n- [디버깅]\\(/ko-KR/help/debugging\\) - 디버깅 도구와 기법\n- [확장 프로그램 개발]\\(/ko-KR/reference/extension-development\\) - 플러그인 테스트\n- [개발 가이드]\\(/ko-KR/reference/contributing\\) - 기여 방법\nENDOFFILE)",
      "Bash(\"D:\\\\project\\\\openclaw\\\\docs\\\\ko-KR\\\\tools\\\\browser-login.md\" << 'ENDOFFILE'\n---\nsummary: \"브라우저 자동화를 위한 수동 로그인과 X/Twitter 게시\"\nread_when:\n  - 브라우저 자동화에서 로그인이 필요할 때\n  - X/Twitter에 게시하고 싶을 때\n  - 브라우저 프로필 설정을 이해하고 싶을 때\ntitle: \"브라우저 로그인\"\n---\n\n# 브라우저 로그인\n\n브라우저 자동화 도구를 사용할 때 웹사이트에 로그인하는 방법과 X/Twitter 게시 워크플로우입니다.\n\n## 핵심 원칙\n\n> **수동 로그인을 권장합니다.** 자동화된 로그인은 봇 감지 시스템을 트리거할 수 있습니다.\n\nOpenClaw는 `openclaw`이라는 이름의 **전용 Chrome 프로필**을 사용합니다 \\(주황색 UI 구분\\). 이 프로필은 일상 브라우저와 분리됩니다.\n\n## 수동 로그인 \\(권장\\)\n\n### 방법 1: 에이전트를 통해 열기\n\n에이전트에게 브라우저를 열도록 요청한 뒤, 직접 로그인합니다:\n\n1. 에이전트: \"브라우저에서 X.com을 열어줘\"\n2. 브라우저가 열리면 직접 로그인\n3. 로그인 완료 후 에이전트에게 작업 요청\n\n### 방법 2: CLI로 열기\n\n```bash\n# 브라우저 시작\nopenclaw browser start\n\n# 특정 URL로 열기\nopenclaw browser open https://x.com\n```\n\n### 방법 3: 특정 프로필 사용\n\n```bash\nopenclaw browser open https://x.com --browser-profile openclaw\n```\n\n기본 프로필은 `openclaw`입니다.\n\n## Chrome 프로필\n\n### 전용 프로필\n\n| 항목        | 설명                                  |\n| ----------- | ------------------------------------- |\n| **이름**    | `openclaw`                            |\n| **구분**    | 주황색 UI로 일상 브라우저와 구분      |\n| **쿠키**    | 일상 브라우저와 분리된 세션           |\n| **목적**    | 에이전트 전용 자동화                  |\n\n### 프로필 분리의 이점\n\n- 일상 브라우저 세션에 영향 없음\n- 자동화 전용 로그인 유지\n- 봇 감지 리스크 감소\n\n## X/Twitter: 권장 워크플로우\n\nX/Twitter은 봇 감지가 엄격한 사이트입니다.\n\n### 읽기/검색/스레드\n\n**호스트 브라우저**에서 수동 로그인 후 사용:\n\n1. 수동으로 X.com에 로그인\n2. 에이전트에게 브라우저 조작 요청\n3. 로그인된 세션으로 컨텐츠 읽기/검색\n\n### 게시하기\n\n**호스트 브라우저**에서 수동 로그인 후 게시:\n\n1. 수동으로 X.com에 로그인\n2. 에이전트가 트윗 작성 후 게시\n3. 중요: 게시 전 내용 확인 권장\n\n## 샌드박스와 호스트 브라우저 접근\n\n### 샌드박스 세션의 제한\n\n샌드박스에서 실행되는 브라우저 세션은 봇 감지를 **더 쉽게 트리거**합니다. X/Twitter같은 엄격한 사이트에서는 **호스트 브라우저**를 사용하세요.\n\n### 호스트 브라우저 접근 허용\n\n샌드박스 에이전트가 호스트 브라우저에 접근하도록 설정합니다:\n\n```json5\n{\n  agents: {\n    defaults: {\n      sandbox: {\n        mode: \"non-main\",\n        browser: {\n          allowHostControl: true,  // 호스트 브라우저 접근 허용\n        },\n      },\n    },\n  },\n}\n```\n\n### CLI로 호스트 브라우저 열기\n\n```bash\nopenclaw browser open https://x.com --browser-profile openclaw --target host\n```\n\n## 자동 로그인을 피해야 하는 이유\n\n| 문제                     | 설명                                  |\n| ------------------------ | ------------------------------------- |\n| **봇 감지**              | 자동화된 로그인 패턴이 감지됨         |\n| **CAPTCHA**              | 자동화 시 CAPTCHA가 더 자주 나타남    |\n| **계정 잠금**            | 의심스러운 활동으로 계정 일시 정지    |\n| **2FA 처리**             | 자동화로 2FA를 처리하기 어려움        |\n| **자격 증명 노출**       | 에이전트에 비밀번호를 전달하면 보안 위험 |\n\n## 로그인 유지 팁\n\n1. **한 번 수동 로그인**: 전용 프로필에서 로그인하면 쿠키가 유지됩니다\n2. **세션 만료 시**: 다시 수동으로 로그인하세요\n3. **여러 사이트**: 필요한 모든 사이트에 미리 로그인해두세요\n4. **프로필 백업**: Chrome 프로필 디렉토리를 백업할 수 있습니다\n\n## 사이트별 참고사항\n\n| 사이트        | 봇 감지 | 권장 방식                |\n| ------------- | ------- | ------------------------ |\n| **X/Twitter** | 엄격    | 호스트 브라우저, 수동 로그인 |\n| **GitHub**    | 보통    | 전용 프로필에서 수동 로그인 |\n| **Google**    | 엄격    | 전용 프로필에서 수동 로그인 |\n| **LinkedIn**  | 엄격    | 호스트 브라우저, 수동 로그인 |\n| **일반 사이트** | 낮음  | 전용 프로필 또는 자동화 가능 |\n\n## 다음 단계\n\n- [브라우저]\\(/ko-KR/tools/browser\\) - 브라우저 자동화 전체 가이드\n- [명령어 실행]\\(/ko-KR/tools/exec\\) - 명령어 실행 보안\n- [멀티 에이전트 샌드박스]\\(/ko-KR/tools/multi-agent-sandbox-tools\\) - 도구 접근 제어\nENDOFFILE)"
    ]
  }
}
